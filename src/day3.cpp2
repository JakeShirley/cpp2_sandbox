
Coordinate : @struct type = {
    x: size_t = 0;
    y: size_t = 0;

    operator==: (this, that) -> bool = {
        return this.x == that.x && this.y == that.y;
    }
}

SchematicEntryType : @enum type = {
    Unknown;
    Symbol;
    Number;
    Space;
}

SchematicEntry : @struct type = {
    occupiedSpaces: std::vector<Coordinate> = ();
    type: SchematicEntryType = SchematicEntryType::Unknown;
    startingSpace: Coordinate = ();
    rawValue: std::string = ();

    operator==: (this, that) -> bool = {
        return this.startingSpace.x == that.startingSpace.x && this.startingSpace.y == that.startingSpace.y;
    }

    calculateNeighbors: (this) -> std::vector<Coordinate> = {
        result: std::vector<Coordinate> = ();
        for occupiedSpaces do (space) {
            for std::views::iota(-1, 2) do (x) {
                for std::views::iota(-1, 2) do (y) {
                    // Don't add your self to the neighbors!
                    if x == 0 && y == 0 {
                        break;
                    }
                    coord: Coordinate = (space.x + x, space.y + y);
                    result.push_back(coord);
                }
            }
        }
        result.erase(
            std::unique(result.begin(), result.end(), :(a, b) -> bool = {
                return a.x == b.x && a.y == b.y;
            }), result.end());

        return result;
    }
}

main: () -> int = {
    input: std::ifstream = std::ifstream("inputs/day3.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return -1;
    }

    
    lineValue: std::string = ();
    partialNumber: std::optional<std::string> = std::nullopt;

    schematicEntries: std::vector<SchematicEntry> = ();

    y: size_t = 0;
    while (std::getline(input, lineValue)) {
        x: size_t = 0;
        for lineValue do (entry) {
            if entry >= '0' && entry <= '9' {
                if !partialNumber.has_value() {
                    partialNumber = std::string();
                }
                partialNumber* += entry;
            } else {
                // Store number if we got to the end of the number
                if partialNumber.has_value() {
                    numberEntry: SchematicEntry = ();
                    numberEntry.type = SchematicEntryType::Number;

                    startingX := x - partialNumber*.length() - 1;
                    numberEntry.startingSpace = (startingX, y);
                    for partialNumber* do (_) {
                        letterCoordinate: Coordinate = (startingX++, y);
                        numberEntry.occupiedSpaces.push_back(letterCoordinate);
                    }
                    numberEntry.rawValue = partialNumber.value();

                    schematicEntries.push_back(numberEntry);
                    partialNumber = std::nullopt;
                }

                if entry == '.' {
                    numberEntry: SchematicEntry = ();
                    numberEntry.type = SchematicEntryType::Space;
                    numberEntry.startingSpace = (x, y);
                    numberEntry.occupiedSpaces.push_back(numberEntry.startingSpace);
                    numberEntry.rawValue = ".";
                    schematicEntries.push_back(numberEntry);
                } else { // Assume symbol
                    numberEntry: SchematicEntry = ();
                    numberEntry.type = SchematicEntryType::Symbol;
                    numberEntry.startingSpace = (x, y);
                    numberEntry.occupiedSpaces.push_back(numberEntry.startingSpace);

                    rawValue: std::string = ".";
                    rawValue[0] = entry;
                    numberEntry.rawValue = rawValue;
                    schematicEntries.push_back(numberEntry);
                }
            }
            x++;
        }

        if partialNumber.has_value() {
            numberEntry: SchematicEntry = ();
            numberEntry.type = SchematicEntryType::Number;

            startingX := x - partialNumber*.length() - 1;
            numberEntry.startingSpace = (startingX, y);
            for partialNumber* do (_) {
                letterCoordinate: Coordinate = (startingX++, y);
                numberEntry.occupiedSpaces.push_back(letterCoordinate);
            }
            numberEntry.rawValue = partialNumber.value();

            schematicEntries.push_back(numberEntry);
            partialNumber = std::nullopt;
        }

        y++;
    }

    symbolsView := schematicEntries | std::views::filter(:(a) -> bool = {
        return a.type == SchematicEntryType::Symbol;
    });

    numbersAdded: std::vector<Coordinate> = ();
    totalNumbersCount: int = 0;
    totalGearRatio: int = 0;
    totalGears: int = 0;
    for symbolsView do (symbolEntry) {
        allNeighbors: std::unordered_map<std::string, SchematicEntry> = ();
        
        for symbolEntry.calculateNeighbors() do (neighborLoc) {
            neighborSymbolItr := std::find_if(schematicEntries.begin(), schematicEntries.end(), :(potentialNeighborSymbol) -> bool = {
                return std::find(potentialNeighborSymbol.occupiedSpaces.begin(), 
                                potentialNeighborSymbol.occupiedSpaces.end(),
                                neighborLoc&$*)
                                != potentialNeighborSymbol.occupiedSpaces.end();
            });

            if neighborSymbolItr != schematicEntries.end() {
                neighborSymbol := neighborSymbolItr*;
                if neighborSymbol.type == SchematicEntryType::Number {
                    allNeighbors[neighborSymbol.rawValue] = neighborSymbol;

                    existingEntry := std::find(numbersAdded.begin(), numbersAdded.end(), neighborSymbol.startingSpace);
                    if existingEntry == numbersAdded.end() {
                        std::cout << "Found new number neighbor: '" 
                            << neighborSymbol.rawValue 
                            << "', at " << neighborLoc.x
                            << ", " << neighborLoc.y
                            << " for symbol '" << symbolEntry.rawValue 
                            << "' at " << symbolEntry.startingSpace.x << ", " << symbolEntry.startingSpace.y
                            << std::endl;

                        totalNumbersCount += std::atoi(neighborSymbol.rawValue.c_str());
                        numbersAdded.push_back(neighborSymbol.startingSpace);
                    }
                }
            }
        }

        if symbolEntry.rawValue == "*" {
            if allNeighbors.size() == 2u {
                firstValue := allNeighbors.begin()*.second;
                secondItr := allNeighbors.begin();
                secondItr++;
                secondValue := secondItr*.second;

                gearRatio := std::atoi(firstValue.rawValue.c_str()) * std::atoi(secondValue.rawValue.c_str());
                std::cout << "Gear found at " << symbolEntry.startingSpace.x << ", " << symbolEntry.startingSpace.y 
                    << " with gear ratio " << gearRatio << "(" << firstValue.rawValue << "x" << secondValue.rawValue << ")" << std::endl;
                totalGears++;
                totalGearRatio += gearRatio;
            }
        }
    }

    std::cout << "Total value: " << totalNumbersCount << " from " << numbersAdded.size() << " numbers" << std::endl;
    std::cout << "Gears: " << totalGears << " with gear ratio of " << totalGearRatio << std::endl;
}