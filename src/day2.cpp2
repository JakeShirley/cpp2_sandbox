
Game : @struct type = {
    Round : @struct type = {
        redCubes: int = 0;
        greenCubes: int = 0;
        blueCubes: int = 0;

        parse: (text: std::string) -> Round = {
            colorStart := 0;
            comma := text.find(',', colorStart);

            result: Round = ();

            while true {
                colorString := text.substr(colorStart, comma - colorStart);

                spaceLoc := colorString.find_first_of(' ');
                count := std::atoi(colorString.substr(0, spaceLoc).c_str());
                color := colorString.substr(spaceLoc + 1);

                if color == "red" {
                    result.redCubes += count;
                } else if color == "blue" {
                    result.blueCubes += count;
                } else if color == "green" {
                    result.greenCubes += count;
                }

                if comma == std::string::npos {
                    break;
                }

                colorStart = comma + 2;
                comma = text.find(',', colorStart);
            }
            
            return result;
        }
    }

    parse: (text: std::string) -> Game = {
        colonPos := text.find_first_of(':');
        spacePos := text.find_first_of(' ');
        gameString: std::string = text.substr(spacePos, colonPos - spacePos);

        result: Game = ();
        result.id = std::atoi(gameString.c_str());
        result.raw = text;

        roundStart := colonPos + 2;
        semiColon := text.find(';', roundStart);

        while true {
            roundSubstr := text.substr(roundStart, semiColon - roundStart);
            parsedRound := Round::parse(roundSubstr);
            
            result.rounds.push_back(parsedRound);

            if semiColon == std::string::npos {
                break;
            }
            
            roundStart = semiColon + 2;
            semiColon = text.find(';', roundStart);
        }
        
        return result;
    }

    possiblePick: (this, redCubes: int, blueCubes: int, greenCubes: int) -> bool = {
        if id == 95 {
            std::cout << "test";
            std::cout << "test2";
        }
        for rounds do (round) {
            if round.redCubes > redCubes {
                return false;
            } else if round.greenCubes > greenCubes  {
                return false;
            } else if round.blueCubes > blueCubes {
                return false;
            }
        }

        return true;
    }

    calculateMinimumPossibleRound: (this) -> Round = {
        result: Round = ();
        for rounds do (round) {
            result.redCubes = std::max(round.redCubes, result.redCubes);
            result.blueCubes = std::max(round.blueCubes, result.blueCubes);
            result.greenCubes = std::max(round.greenCubes, result.greenCubes);
        }
        return result;
    }

    public rounds: std::vector<Round> = ();
    public id: int = 0;
    public raw: std::string = ();
}

main: () -> int = {
    input: std::ifstream = std::ifstream("inputs/day2.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return -1;
    }

    lineValue: std::string = ();
    games: std::vector<Game> = ();
    while (std::getline(input, lineValue)) {
        game := Game::parse(lineValue);
        games.push_back(game);
    }

    idSum: int = 0;
    powerSum: int = 0;
    for games do (game) {
        if game.possiblePick(12, 14, 13) {
            std::cout << "Game " << game.id << " is possible!" << std::endl;
            std::cout << "\t" << game.raw << std::endl;
            idSum += game.id;
        }

        minRound := game.calculateMinimumPossibleRound();
        power := minRound.redCubes * minRound.blueCubes * minRound.greenCubes;
        powerSum += power;
    }

    std::cout << "ID Sum of possible games: " << idSum << std::endl;
    std::cout << "Total min round power: " << powerSum << std::endl;
}