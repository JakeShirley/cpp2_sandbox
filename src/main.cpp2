
GalaxyLocatiom : @struct type = {
    x: size_t;
    y: size_t;

    operator==: (this, that) -> bool = {
        return this.x == that.x && this.y == that.y;
    }

    operator<: (this, that) -> bool = {
        return std::tie(this.x, this.y) < std::tie(that.x, that.y);
    }
}

expandUniverse: (inout universe: std::vector<std::string>) = {
    emptyRows: std::vector<size_t> = ();
    emptyColumns: std::vector<size_t> = ();

    universeWidth: size_t = universe[0].size();

    // Rows
    for std::views::iota(0u, universe.size()) do (lineIndex) {
        if universe[lineIndex].find('#') == std::string::npos {
            emptyRows.push_back(lineIndex);
        }
    }

    // Columns
    for std::views::iota(0u, universeWidth) do (charIndex) {
        if std::ranges::none_of(universe, :(line) -> bool = {
            return line[charIndex$] == '#'; 
        }) {
            emptyColumns.push_back(charIndex);
        }
    }

    // Rows
    for emptyRows | std::views::reverse do (emptyRowIndex) {
        universe.insert(universe.begin() + emptyRowIndex, std::string(universeWidth, '.'));
    }

    // Columns
    for std::views::iota(0u, universe.size()) do (lineIndex) {
        for emptyColumns | std::views::reverse do (emptyColumnIndex) {
            universe[lineIndex].insert(emptyColumnIndex, 1, '.');
        }
    }
}

print: (universe: std::vector<std::string>) = {
    std::cout << "Universe: " << std::endl;
    for universe do (line) {
        std::cout << line << std::endl;
    }
    std::cout << std::endl;
}

findGalaxyLocations: (universe: std::vector<std::string>) -> std::vector<GalaxyLocatiom> = {
    galaxyLocations: std::vector<GalaxyLocatiom> = ();
    for universe do (lineIndex) {
        for std::views::iota(0u, universe[lineIndex].size()) do (charIndex) {
            if universe[lineIndex][charIndex] == '#' {
                galaxyLocations.emplace_back(charIndex, lineIndex);
            }
        }
    }
    return galaxyLocations;
}

makeGalaxyPair: (galaxy1: GalaxyLocatiom, galaxy2: GalaxyLocatiom) -> std::pair<GalaxyLocatiom, GalaxyLocatiom> = {
    if galaxy1 < galaxy2 {
        return std::make_pair(galaxy1, galaxy2);
    } else {
        return std::make_pair(galaxy2, galaxy1);
    }
}

part1: () -> int = {
    input: std::ifstream = std::ifstream("inputs/day11_debug.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return -1;
    }

    universe: std::vector<std::string> = ();
    inputStr: std::string = ();
    while (std::getline(input, inputStr)) {
        universe.push_back(inputStr);
    }

    universe.print();
    expandUniverse(universe);
    universe.print();

    galaxies := universe.findGalaxyLocations();

    galaxyPairs: std::vector<std::pair<GalaxyLocatiom, GalaxyLocatiom>> = ();
    for galaxies do (galaxy1) {
        for galaxies do (galaxy2) {
            if galaxy1 != galaxy2 {
                pair := makeGalaxyPair(galaxy1, galaxy2);
                if std::find(galaxyPairs.begin(), galaxyPairs.end(), pair) == galaxyPairs.end() {
                    galaxyPairs.push_back(pair);
                }   
            }
        }
    }
    
    std::cout << "Path length: " << 1 << std::endl;

    return 0;
}

part2: () -> int = {
    return 0;
}

main: () -> int = {
    return part1();
    //return part2();
}