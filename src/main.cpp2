Location: @value type = {
    public x: int64_t = 0;
    public y: int64_t = 0;

    operator=:(out this, x_: int64_t, y_: int64_t) = {
        x = x_;
        y = y_;
    }
}

printGrid: (inout grid: std::vector<std::string>, inout queue: std::vector<Location>) = {
    for std::views::iota(0u, grid.size()) do (y) {
        for std::views::iota(0u, grid[y].size()) do (x) {
            locItr := std::find(queue.begin(), queue.end(), Location(x, y));
            if locItr != queue.end() {
                std::cout << 'O';
                continue;
            }

            std::cout << grid[y][x];
        }
        std::cout << std::endl;
    }
}

queueLocation: (inout grid: std::vector<std::string>, inout queue: std::vector<Location>, x: int64_t, y: int64_t) = {
    // Walked into a rock
    if grid[y][x] == '#' {
        return;
    }

    // Walked off the edge
    if x < 0 || x >= cpp2::unsafe_narrow<int64_t>(grid[0].size()) || y < 0 || y >= cpp2::unsafe_narrow<int64_t>(grid.size()) {
        return;
    }

    locItr := std::find(queue.begin(), queue.end(), Location(x, y));
    if locItr == queue.end() {
        queue.push_back(Location(x, y));
    }
}

queueLocationInfinite: (inout grid: std::vector<std::string>, inout queue: std::vector<Location>, x: int64_t, y: int64_t) = {
    actualX =: x % cpp2::unsafe_narrow<int64_t>(grid[0].size());
    actualY =: y % cpp2::unsafe_narrow<int64_t>(grid.size());

    // Walked into a rock
    if grid[actualX][actualY] == '#' {
        return;
    }

    locItr := std::find(queue.begin(), queue.end(), Location(x, y));
    if locItr == queue.end() {
        queue.push_back(Location(x, y));
    }
}

walkGarden: (inout grid: std::vector<std::string>, steps: int64_t, startX: int64_t, startY: int64_t) -> uint64_t = {

    locationQueue: std::vector<Location> = ();
    locationQueue.push_back(Location(startX, startY));

    stepsLeft := steps;

    while stepsLeft >= 0 {
        currentQueue := (move locationQueue);
        stepsLeft -= 1;

        //printGrid(grid, currentQueue&*);
        //std::cout << std::endl;

        for currentQueue do (location) {

            queueLocation(grid, locationQueue, location.x + 1, location.y);
            queueLocation(grid, locationQueue, location.x - 1, location.y);
            queueLocation(grid, locationQueue, location.x, location.y + 1);
            queueLocation(grid, locationQueue, location.x, location.y - 1);
        }
    }

    return locationQueue.size();
}


walkGardenInfinite: (inout grid: std::vector<std::string>, steps: int64_t, startX: int64_t, startY: int64_t) -> uint64_t = {

    locationQueue: std::vector<Location> = ();
    locationQueue.push_back(Location(startX, startY));

    stepsLeft := steps;

    while stepsLeft >= 0 {
        currentQueue := (move locationQueue);
        stepsLeft -= 1;

        //printGrid(grid, currentQueue&*);
        //std::cout << std::endl;

        for currentQueue do (location) {

            queueLocation(grid, locationQueue, location.x + 1, location.y);
            queueLocation(grid, locationQueue, location.x - 1, location.y);
            queueLocation(grid, locationQueue, location.x, location.y + 1);
            queueLocation(grid, locationQueue, location.x, location.y - 1);
        }
    }

    return locationQueue.size();
}

part1: (debugLog: bool) = {
    input: std::ifstream = std::ifstream("inputs/day21.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return;
    }

    inputStr: std::string = ();
    lines : std::vector<std::string> = ();

    while (input.getline(inputStr)) {
        lines.push_back(move inputStr);
    }

    startPosx : int64_t = 0;
    startPosy : int64_t = 0;
    for std::views::iota(0u, lines.size()) do(y) {
        for std::views::iota(0u, lines[y].size()) do (x) {
            if lines[y][x] == 'S' {
                startPosx = x;
                startPosy = y;
            }
        }
    }

    gardens := walkGarden(lines&*, 63, startPosx, startPosy);
    std::cout << "Part 1: " << gardens << std::endl;
}

part2: (debugLog: bool) = {
    input: std::ifstream = std::ifstream("inputs/day21_debug1.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return;
    }

    inputStr: std::string = ();
    lines : std::vector<std::string> = ();

    while (input.getline(inputStr)) {
        lines.push_back(move inputStr);
    }

    startPosx : int64_t = 0;
    startPosy : int64_t = 0;
    for std::views::iota(0u, lines.size()) do(y) {
        for std::views::iota(0u, lines[y].size()) do (x) {
            if lines[y][x] == 'S' {
                startPosx = x;
                startPosy = y;
            }
        }
    }

    gardens := walkGarden(lines&*, 63, startPosx, startPosy);
    std::cout << "Part 2: " << gardens << std::endl;
}

main: () -> int = {
    part1(false);
    std::cout << std::endl;
    part2(false);

    return 0;
}