Direction : @flag_enum<u8> type = {
    None := 0;
    Up;
    Down;
    Left;
    Right;
}

HeatLossCache : @value type = {
    public x: size_t = 0;
    public y: size_t = 0;
    public direction: Direction = Direction::None;
    public heatLoss: size_t = 0;
}

StackState : @struct type = {
    public x: size_t;
    public y: size_t;
    public heatLoss: size_t;
    public direction: Direction;
    public spacesInDirection: size_t;
    public path: std::vector<std::shared_ptr<StackState>>;

    pathContains: (this, otherX: size_t, otherY: size_t) -> bool = {
        for path do (pathState) {
            if pathState*.x == otherX && pathState*.y == otherY {
                return true;
            }
        }
        return false;
    }

    mustTurn: (this) -> Direction = {
        if path.size() >= 3u {
            if path[path.size() - 1]*.direction == path[path.size() - 2]*.direction == path[path.size() - 3]*.direction {
                return path[path.size() - 1]*.direction;
            }
        }

        return Direction::None;
    }

    calculateHeatLoss: (this, inout grid: std::vector<std::string>) -> size_t = {
        totalHeatLoss := 0;
        for path do (pathState) {
            totalHeatLoss += grid[pathState*.y][pathState*.x] - '0';
        }
        return totalHeatLoss;
    }
}

projectCoordinates: (direction: Direction, x: size_t, y: size_t) -> std::tuple<size_t, size_t> = {
    if direction == Direction::Up {
        return std::make_tuple(x, y - 1);
    } else if direction == Direction::Down {
        return std::make_tuple(x, y + 1);
    } else if direction == Direction::Left {
        return std::make_tuple(x - 1, y);
    } else if direction == Direction::Right {
        return std::make_tuple(x + 1, y);
    }
    return std::make_tuple(x, y);
}

printPath: (inout grid: std::vector<std::string>, inout path: std::vector<std::shared_ptr<StackState>>, currentState: std::shared_ptr<StackState>) = {
    for std::views::iota(0u, grid.size()) do (lineIndex) {
        for std::views::iota(0u, grid[lineIndex].size()) do (cellIndex) {
            if currentState {
                currentStateValue := currentState*;

                if currentStateValue.x == cellIndex && currentStateValue.y == lineIndex {
                    std::cout << "@";
                    continue;
                }
               
                pathItr := std::find_if(path.begin(), path.end(), :(state) -> bool = {
                    return state*.x == cellIndex$ && state*.y == lineIndex$;
                });

                if pathItr != path.end() {
                    pathState := pathItr*;
                    if pathState*.direction == Direction::Up {
                        std::cout << "^";
                    } else if pathState*.direction == Direction::Down {
                        std::cout << "v";
                    } else if pathState*.direction == Direction::Left {
                        std::cout << "<";
                    } else if pathState*.direction == Direction::Right {
                        std::cout << ">";
                    }
                } else {
                    std::cout << grid[lineIndex][cellIndex];
                }
            } else {
                std::cout << grid[lineIndex][cellIndex];
            }
        }
        std::cout << std::endl;
    }
}

queueTravel: (inout grid: std::vector<std::string>, inout visitQueue: std::vector<std::shared_ptr<StackState>>, currentState: std::shared_ptr<StackState>, direction: Direction) = {
    nextCoords := projectCoordinates(direction, currentState*.x, currentState*.y);

    if nextCoords.get<1>() >= grid.size() || nextCoords.get<0>() >= grid[nextCoords.get<1>()].size() {
        return;
    }

    //if currentState*.pathContains(nextCoords.get<0>(), nextCoords.get<1>()) {
    //    return;
    //} else 
    if currentState*.direction == direction && currentState*.spacesInDirection >= 2u {
        return;
    }

    nextState := std::make_shared<StackState>(currentState*);
    nextState*.x = nextCoords.get<0>();
    nextState*.y = nextCoords.get<1>();
    nextState*.direction = direction;
    nextState*.heatLoss += grid[nextState*.y][nextState*.x] - '0';

    if direction == currentState*.direction {
        nextState*.spacesInDirection += 1;
    } else {
        nextState*.spacesInDirection = 1u;
    }
    //nextState*.path.push_back(currentState);

    visitQueue.push_back(move nextState);
}

walkPath: (inout grid: std::vector<std::string>, debugLog: bool, startX: size_t, startY: size_t) -> std::vector<std::shared_ptr<StackState>> = {
    results: std::vector<std::shared_ptr<StackState>> = ();
    visitQueue: std::vector<std::shared_ptr<StackState>> = ();
    heatLossCache: std::map<HeatLossCache, size_t> = ();
    
    goRight := std::make_shared<StackState>();
    goRight*.x = startX;
    goRight*.y = startY;
    goRight*.direction = Direction::Right;
    visitQueue.push_back(move goRight);

    goDown := std::make_shared<StackState>();
    goDown*.x = startX;
    goDown*.y = startY;
    goDown*.direction = Direction::Down;
    visitQueue.push_back(move goDown);

    iterationCount := 0;
    while (!visitQueue.empty()) {
        currentState := visitQueue[0];
        visitQueue.erase(visitQueue.begin());

        if currentState*.y == grid.size() - 1 && currentState*.x == grid[0].size() - 1 {
            results.push_back(move currentState);
            continue;
        }

        cacheKey := HeatLossCache();
        cacheKey.x = currentState*.x;
        cacheKey.y = currentState*.y;
        cacheKey.direction = currentState*.direction;
        cacheKey.heatLoss = currentState*.heatLoss;
        heatLossCacheItr := heatLossCache.find(cacheKey);
        if heatLossCacheItr != heatLossCache.end() {
            if currentState*.heatLoss < heatLossCacheItr*.second {
                heatLossCache[cacheKey] = currentState*.heatLoss;
            } else {
                continue;
            }
        } else {
            heatLossCache[cacheKey] = currentState*.heatLoss;
        }
        

        iterationCount++;
        if debugLog && iterationCount % 1000 == 0{
            std::cout << "Iteration " << iterationCount << ", queue size: " << visitQueue.size() << std::endl;
            printPath(grid, currentState*.path, currentState);
            std::cout << std::endl;
        }
        
        queueTravel(grid, visitQueue, currentState, Direction::Up);
        queueTravel(grid, visitQueue, currentState, Direction::Left);
        queueTravel(grid, visitQueue, currentState, Direction::Right);
        queueTravel(grid, visitQueue, currentState, Direction::Down);
    }

    return results;
}

part1: (debugLog: bool) = {
    input: std::ifstream = std::ifstream("inputs/day17_debug.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return;
    }

    inputStr: std::string = ();
    lines : std::vector<std::string> = ();
    while (input.getline(inputStr)) {
        lines.push_back(move inputStr);
    }

    result := walkPath(lines&*, false, 0u, 0u);

    leastHeatLoss := std::numeric_limits<size_t>::max();
    leastHeatLossState := std::shared_ptr<StackState>();
    for result do (resultState) {
        heatLoss := resultState*.heatLoss;
        if heatLoss < leastHeatLoss {
            leastHeatLoss = heatLoss;
            leastHeatLossState = resultState;
        }
    }

    printPath(lines&*, leastHeatLossState*.path, leastHeatLossState);
    std::cout << "Part 1: " << leastHeatLoss << std::endl;
}

part2: (debugLog: bool) = {
    std::cout << "Part 2: " << "n/a" << std::endl;
}

main: () -> int = {
    part1(true);
    part2(false);

    return 0;
}