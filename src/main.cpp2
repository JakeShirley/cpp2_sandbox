Direction : @flag_enum<u8> type = {
    None := 0;
    Up;
    Down;
    Left;
    Right;
}

DiggerInstruction : @struct type = {
    distance: size_t;
    direction: Direction = Direction::None;
    color: uint32_t = 0;
    debug: std::string;
}

Location : @value type = {
    public x: int32_t = 0;
    public y: int32_t = 0;

    offset: (this, distance: size_t, direction: Direction) -> Location = {
        result := Location(this);
        if direction == Direction::Up {
            result.y -= distance;
        } else if direction == Direction::Down {
            result.y += distance;
        } else if direction == Direction::Left {
            result.x -= distance;
        } else if direction == Direction::Right {
            result.x += distance;
        } else {
            std::cout << "UNKNOWN DIRECTION!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
        }
        return result;
    }
}

print: (self: std::vector<std::vector<i32>>, inout stream: std::ostream) = {
    for self do (row) {
        for row do (c) {
            if c == 0 {
                stream << '.';
            } else {
                stream << '#';
            }
        }
        stream << std::endl;
    }
}

// Stupid flood fill
digOut: (inout self: std::vector<std::vector<i32>>, startLocation: Location) = {

    visitQueue: std::vector<Location> = ();

    visitQueue.push_back(move startLocation);

    while !visitQueue.empty() {
        currentLocation := visitQueue[0];
        visitQueue.erase(visitQueue.begin());

        if currentLocation.x < 0 || currentLocation.y < 0 || currentLocation.x >= cpp2::unsafe_narrow<i32>(self[0].size()) || currentLocation.y >= cpp2::unsafe_narrow<i32>(self.size()) {
            continue;
        }

        if self[currentLocation.y][currentLocation.x] != 0 {
            continue;
        }

        self[currentLocation.y][currentLocation.x] = 1;

        up := Location(currentLocation);
        up.y -= 1;
        visitQueue.push_back(move up);

        down := Location(currentLocation);
        down.y += 1;
        visitQueue.push_back(move down);

        left := Location(currentLocation);
        left.x -= 1;
        visitQueue.push_back(move left);

        right := Location(currentLocation);
        right.x += 1;
        visitQueue.push_back(move right);
    }
}

part1: (debugLog: bool) = {
    input: std::ifstream = std::ifstream("inputs/day18.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return;
    }

    inputStr: std::string = ();
    instructions : std::vector<DiggerInstruction> = ();
    while (input.getline(inputStr)) {
        instruction: DiggerInstruction = ();
        
        firstSpace := inputStr.find_first_of(' ');
        lastSpace := inputStr.find_last_of(' ');

        rawDirection := inputStr.substr(0, firstSpace);
        rawDistance := inputStr.substr(firstSpace + 1, lastSpace);
        rawHex := inputStr.substr(lastSpace + 3, inputStr.length() - lastSpace - 4);

        instruction.distance = std::stoi(rawDistance);
        if rawDirection == "U" {
            instruction.direction = Direction::Up;
        } else if rawDirection == "D" {
            instruction.direction = Direction::Down;
        } else if rawDirection == "L" {
            instruction.direction = Direction::Left;
        } else if rawDirection == "R" {
            instruction.direction = Direction::Right;
        }
        instruction.color = std::stoi(rawHex, 0, 16);
        instruction.debug = (move inputStr);

        instructions.push_back(move instruction);
    }

    currentLocation := Location();
    grid := std::vector<std::vector<i32>>();

    for instructions do (instruction) {
        nextLocation := currentLocation.offset(instruction.distance, instruction.direction);

        if nextLocation.y >= cpp2::unsafe_narrow<i32>(grid.size()) {
            grid.resize(nextLocation.y + 1);

            for std::views::iota(0u, grid.size()) do (rowIndex) {
                grid[rowIndex].resize(grid[0].size(), 0);
            }
        } else if nextLocation.y < 0 {
            gridOffset := std::abs(nextLocation.y);

            for std::views::iota(grid.size(), grid.size() + gridOffset) do (_) {
                grid.insert(grid.begin(), std::vector<i32>());
            }

            for std::views::iota(0u, grid.size()) do (rowIndex) {
                grid[rowIndex].resize(grid.back().size(), 0);
            }

            nextLocation.y += gridOffset;
            currentLocation.y += gridOffset;
        }

        if nextLocation.x >= cpp2::unsafe_narrow<i32>(grid[0].size()) {
            for std::views::iota(0u, grid.size()) do (rowIndex) {
                grid[rowIndex].resize(nextLocation.x + 1, 0);
            }
        } else if nextLocation.x < 0 {
            gridOffset := std::abs(nextLocation.x);
           for std::views::iota(0u, grid.size()) do (rowIndex) {
                for std::views::iota(grid[rowIndex].size(), grid[rowIndex].size() + gridOffset) do (_) {
                    grid[rowIndex].insert(grid[rowIndex].begin(), 0);
                }
            }

            nextLocation.x += gridOffset;
            currentLocation.x += gridOffset;
        }

        if instruction.direction == Direction::Right {
            for std::views::iota(currentLocation.x, nextLocation.x + 1) do (x) {
                grid[currentLocation.y][x] = instruction.color;
            }
        } else if instruction.direction == Direction::Left  {
            for std::views::iota(nextLocation.x, currentLocation.x + 1) do (x) {
                grid[currentLocation.y][x] = instruction.color;
            }
        } else if instruction.direction == Direction::Up {
            for std::views::iota( nextLocation.y, currentLocation.y + 1) do (y) {
                grid[y][currentLocation.x] = instruction.color;
            }
        } else if instruction.direction == Direction::Down {
            for std::views::iota(currentLocation.y, nextLocation.y + 1) do (y) {
                grid[y][currentLocation.x] = instruction.color;
            }
        }

        currentLocation = nextLocation;
        //std::cout << "Instruction: " << instruction.debug << std::endl;
        //grid.print(std::cout);
        //std::cout << std::endl;
    }

    outFileBefore := std::ofstream("out_before.txt");
    outFileAfter := std::ofstream("out_after.txt");


    std::cout << "Before digout:" << std::endl;
    print(grid&*, outFileBefore&*);

    std::cout << "After digout:" << std::endl;

    // Found by hand :D
    start := Location();
    start.x = 248;
    start.y = 16;

    // Debug example
    //start := Location();
    //start.x = 1;
    //start.y = 1;

    grid.digOut(start);
    print(grid&*, outFileAfter&*);

    totalScore := 0;
    for grid do (row) {
        for row do (c) {
            if c != 0 {
                totalScore += 1;
            }
        }
    }

    std::cout << "Part 1: " << totalScore << std::endl;
}

part2: (debugLog: bool) = {
    input: std::ifstream = std::ifstream("inputs/day18_debug1.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return;
    }

    inputStr: std::string = ();
    instructions : std::vector<DiggerInstruction> = ();
    while (input.getline(inputStr)) {
        instruction: DiggerInstruction = ();
        
        lastSpace := inputStr.find_last_of(' ');
        rawHex := inputStr.substr(lastSpace + 3, inputStr.length() - lastSpace - 4);

        rawNewDistance := rawHex.substr(0, 5);
        rawNewDirection := rawHex[5];

        instruction.distance = std::stoi(rawNewDistance, 0, 16);
        if rawNewDirection == '3' {
            instruction.direction = Direction::Up;
        } else if rawNewDirection == '1' {
            instruction.direction = Direction::Down;
        } else if rawNewDirection == '2' {
            instruction.direction = Direction::Left;
        } else if rawNewDirection == '0' {
            instruction.direction = Direction::Right;
        }
        instruction.color = 1;
        instruction.debug = (move inputStr);

        instructions.push_back(move instruction);
    }

    currentLocation := Location();
    grid := std::vector<std::vector<i32>>();

    for instructions do (instruction) {
        nextLocation := currentLocation.offset(instruction.distance, instruction.direction);

        if nextLocation.y >= cpp2::unsafe_narrow<i32>(grid.size()) {
            grid.resize(nextLocation.y + 1);

            for std::views::iota(0u, grid.size()) do (rowIndex) {
                grid[rowIndex].resize(grid[0].size(), 0);
            }
        } else if nextLocation.y < 0 {
            gridOffset := std::abs(nextLocation.y);

            for std::views::iota(grid.size(), grid.size() + gridOffset) do (_) {
                grid.insert(grid.begin(), std::vector<i32>());
            }

            for std::views::iota(0u, grid.size()) do (rowIndex) {
                grid[rowIndex].resize(grid.back().size(), 0);
            }

            nextLocation.y += gridOffset;
            currentLocation.y += gridOffset;
        }

        if nextLocation.x >= cpp2::unsafe_narrow<i32>(grid[0].size()) {
            for std::views::iota(0u, grid.size()) do (rowIndex) {
                grid[rowIndex].resize(nextLocation.x + 1, 0);
            }
        } else if nextLocation.x < 0 {
            gridOffset := std::abs(nextLocation.x);
           for std::views::iota(0u, grid.size()) do (rowIndex) {
                for std::views::iota(grid[rowIndex].size(), grid[rowIndex].size() + gridOffset) do (_) {
                    grid[rowIndex].insert(grid[rowIndex].begin(), 0);
                }
            }

            nextLocation.x += gridOffset;
            currentLocation.x += gridOffset;
        }

        if instruction.direction == Direction::Right {
            for std::views::iota(currentLocation.x, nextLocation.x + 1) do (x) {
                grid[currentLocation.y][x] = instruction.color;
            }
        } else if instruction.direction == Direction::Left  {
            for std::views::iota(nextLocation.x, currentLocation.x + 1) do (x) {
                grid[currentLocation.y][x] = instruction.color;
            }
        } else if instruction.direction == Direction::Up {
            for std::views::iota( nextLocation.y, currentLocation.y + 1) do (y) {
                grid[y][currentLocation.x] = instruction.color;
            }
        } else if instruction.direction == Direction::Down {
            for std::views::iota(currentLocation.y, nextLocation.y + 1) do (y) {
                grid[y][currentLocation.x] = instruction.color;
            }
        }

        currentLocation = nextLocation;
    }

    outFileBefore := std::ofstream("out_before.txt");
    outFileAfter := std::ofstream("out_after.txt");


    std::cout << "Before digout:" << std::endl;
    print(grid&*, outFileBefore&*);

    std::cout << "After digout:" << std::endl;

    // Found by hand :D
    start := Location();
    start.x = 248;
    start.y = 16;

    // Debug example
    //start := Location();
    //start.x = 1;
    //start.y = 1;

    grid.digOut(start);
    print(grid&*, outFileAfter&*);

    totalScore := 0;
    for grid do (row) {
        for row do (c) {
            if c != 0 {
                totalScore += 1;
            }
        }
    }

    std::cout << "Part 2: " << totalScore << std::endl;
}

main: () -> int = {
    //part1(true);
    std::cout << std::endl;
    part2(false);

    return 0;
}