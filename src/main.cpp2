Operation : @enum type = {
    None;
    LessThan;
    GreaterThan;
}

Instruction : @struct type = {
    op: Operation = Operation::None;
    value: int64_t = 0;
    category: char = 0;
    destination: std::string = ();
    debug: std::string = ();
}

InstructionSet : @struct type = {
    instructions: std::vector<Instruction> = ();
    destination: std::string = ();
    name: std::string = ();
    debug: std::string = ();
}

// a<2006:qkq
parseInstruction: (inputStr: std::string) -> Instruction = {
    instruction: Instruction = ();

    colonPos := inputStr.find_first_of(':');

    instruction.destination = inputStr.substr(colonPos + 1);

    rawOp := inputStr.substr(0, colonPos);
    instruction.category = rawOp[0];

    if rawOp[1] == '<' {
        instruction.op = Operation::LessThan;
    } else if rawOp[1] == '>' {
        instruction.op = Operation::GreaterThan;
    } else {
        std::cout << "Unknown operation: " << rawOp[1] << std::endl;
    }

    instruction.value = std::stoi(rawOp.substr(2));

    instruction.debug = (move inputStr);

    return instruction;
}

// hdj{m>838:A,pv}
parseInstructionSet: (inputStr: std::string) -> InstructionSet = {
    instructionSet: InstructionSet = ();

    curlyOpen := inputStr.find_first_of('{');
    curlyClose := inputStr.find_first_of('}');

    instructionSet.name = inputStr.substr(0, curlyOpen);

    instructionsRaw := inputStr.substr(curlyOpen + 1, curlyClose - curlyOpen - 1);

    ss := std::stringstream();
    ss << instructionsRaw;

    instructionRaw := std::string();
    while (std::getline(ss, instructionRaw, ',')) {
        colonPos := instructionRaw.find_first_of(':');
        if colonPos == std::string::npos {
            instructionSet.destination = instructionRaw.substr(colonPos + 1);
            continue;
        }
        instructionSet.instructions.push_back(parseInstruction(move instructionRaw));
    }

    instructionSet.debug = (move inputStr);

    return instructionSet;
}

// {x=787,m=2655,a=1222,s=2876}
parsePartDefinition: (inputStr: std::string) -> std::unordered_map<char, int64_t> = {
    result: std::unordered_map<char, int64_t> = ();

    ss := std::stringstream();
    ss << inputStr.substr(1, inputStr.size() - 2);

    instructionRaw := std::string();
    while (std::getline(ss, instructionRaw, ',')) {
        result[instructionRaw[0]] = std::stoi(instructionRaw.substr(2));
    }

    return result;
}

isPartAccepted: (inout part: const std::unordered_map<char, int64_t>, inout instructions: const std::unordered_map<std::string, InstructionSet>) -> bool = {
    nextInstruction := instructions.at("in");

    while nextInstruction.name != "A" && nextInstruction.name != "R" {
        foundNextInstruction := false;

        currentInstuctions: for nextInstruction.instructions do (instruction) {
            if instruction.op == Operation::LessThan {
                if part.at(instruction.category) < instruction.value {
                    nextInstruction = instructions.at(instruction.destination);
                    foundNextInstruction = true;
                    break currentInstuctions;
                }
            } else if instruction.op == Operation::GreaterThan {
                if part.at(instruction.category) > instruction.value {
                    nextInstruction = instructions.at(instruction.destination);
                    foundNextInstruction = true;
                    break currentInstuctions;
                }
            } else {
                std::cout << "Unknown operation: " << instruction.op.get_raw_value() << std::endl;
            }
        }

        if !foundNextInstruction {
            nextInstruction = instructions.at(nextInstruction.destination);
        }
    }

    return nextInstruction.name == "A";
}

part1: (debugLog: bool) = {
    input: std::ifstream = std::ifstream("inputs/day19.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return;
    }

    inputStr: std::string = ();
    instructions : std::unordered_map<std::string, InstructionSet> = ();
    definitions : std::vector<std::unordered_map<char, int64_t>> = ();

    isParsingDefinitions := false;
    while (input.getline(inputStr)) {
        if inputStr.empty() {
            isParsingDefinitions = true;
            continue;
        }

        if isParsingDefinitions {
            definitions.push_back(parsePartDefinition(move inputStr));
        } else {
            instructionSet := parseInstructionSet(move inputStr);
            instructions[instructionSet.name] = instructionSet;
        }
    }

    // End points
    acceptedInstruction := InstructionSet();
    acceptedInstruction.name = "A";
    rejectedInstruction := InstructionSet();
    rejectedInstruction.name = "R";

    instructions[acceptedInstruction.name] = (move acceptedInstruction);
    instructions[rejectedInstruction.name] = (move rejectedInstruction);

    totalAccepted: uint64_t = 0;
    for std::views::iota(0u, definitions.size()) do (i) {
        isAccepted := isPartAccepted(definitions[i], instructions);
        if isAccepted {
            for definitions[i] do (partPair) {
                totalAccepted += partPair.second;
            }
        }
    }

    std::cout << "Part 1: " << totalAccepted << std::endl;
}

part2: (debugLog: bool) = {
    std::cout << "Part 2: " << "n/a" << std::endl;
}

main: () -> int = {
    part1(false);
    std::cout << std::endl;
    part2(false);

    return 0;
}