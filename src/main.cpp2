Direction : @flag_enum<u8> type = {
    None := 0;
    Up;
    Down;
    Left;
    Right;
}

DiggerInstruction : @struct type = {
    distance: size_t;
    direction: Direction = Direction::None;
    color: uint32_t = 0;
    debug: std::string;
}

Location : @value type = {
    public x: int32_t = 0;
    public y: int32_t = 0;

    offset: (this, distance: size_t, direction: Direction) -> Location = {
        result := Location(this);
        if direction == Direction::Up {
            result.y -= distance;
        } else if direction == Direction::Down {
            result.y += distance;
        } else if direction == Direction::Left {
            result.x -= distance;
        } else if direction == Direction::Right {
            result.x += distance;
        } else {
            std::cout << "UNKNOWN DIRECTION!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
        }
        return result;
    }
}

DiggerWall : @struct type = {
    startLocation: Location;
    endLocation: Location;
    direction: Direction;

    contains: (this, other: Location) -> bool = {
        if other.x >= this.startLocation.x && other.x <= this.endLocation.x && other.y >= this.startLocation.y && other.y <= this.endLocation.y {
            return true;
        }
        return false;
    }
}

calculateExtents: (walls: std::vector<DiggerWall>) -> std::pair<Location, Location> = {
    minLocation := Location();
    minLocation.x = std::numeric_limits<i32>::max();
    minLocation.y = std::numeric_limits<i32>::max();

    maxLocation := Location();
    maxLocation.x = std::numeric_limits<i32>::min();
    maxLocation.y = std::numeric_limits<i32>::min();

    for walls do (wall) {
        if wall.startLocation.x < minLocation.x {
            minLocation.x = wall.startLocation.x;
        }
        if wall.startLocation.y < minLocation.y {
            minLocation.y = wall.startLocation.y;
        }
        if wall.endLocation.x < minLocation.x {
            minLocation.x = wall.endLocation.x;
        }
        if wall.endLocation.y < minLocation.y {
            minLocation.y = wall.endLocation.y;
        }

        if wall.startLocation.x > maxLocation.x {
            maxLocation.x = wall.startLocation.x;
        }
        if wall.startLocation.y > maxLocation.y {
            maxLocation.y = wall.startLocation.y;
        }
        if wall.endLocation.x > maxLocation.x {
            maxLocation.x = wall.endLocation.x;
        }
        if wall.endLocation.y > maxLocation.y {
            maxLocation.y = wall.endLocation.y;
        }
    }

    return std::make_pair(move minLocation, move maxLocation);
}

print: (self: std::vector<std::vector<i32>>, inout stream: std::ostream) = {
    for self do (row) {
        for row do (c) {
            if c == 0 {
                stream << '.';
            } else {
                stream << '#';
            }
        }
        stream << std::endl;
    }
}

// Stupid flood fill
digOut: (inout self: std::vector<std::vector<i32>>, startLocation: Location) = {

    visitQueue: std::vector<Location> = ();

    visitQueue.push_back(move startLocation);

    while !visitQueue.empty() {
        currentLocation := visitQueue[0];
        visitQueue.erase(visitQueue.begin());

        if currentLocation.x < 0 || currentLocation.y < 0 || currentLocation.x >= cpp2::unsafe_narrow<i32>(self[0].size()) || currentLocation.y >= cpp2::unsafe_narrow<i32>(self.size()) {
            continue;
        }

        if self[currentLocation.y][currentLocation.x] != 0 {
            continue;
        }

        self[currentLocation.y][currentLocation.x] = 1;

        up := Location(currentLocation);
        up.y -= 1;
        visitQueue.push_back(move up);

        down := Location(currentLocation);
        down.y += 1;
        visitQueue.push_back(move down);

        left := Location(currentLocation);
        left.x -= 1;
        visitQueue.push_back(move left);

        right := Location(currentLocation);
        right.x += 1;
        visitQueue.push_back(move right);
    }
}

parseInstructionPart1: (inputStr: std::string) -> DiggerInstruction = {
    instruction: DiggerInstruction = ();
        
    firstSpace := inputStr.find_first_of(' ');
    lastSpace := inputStr.find_last_of(' ');

    rawDirection := inputStr.substr(0, firstSpace);
    rawDistance := inputStr.substr(firstSpace + 1, lastSpace);
    rawHex := inputStr.substr(lastSpace + 3, inputStr.length() - lastSpace - 4);

    instruction.distance = std::stoi(rawDistance);
    if rawDirection == "U" {
        instruction.direction = Direction::Up;
    } else if rawDirection == "D" {
        instruction.direction = Direction::Down;
    } else if rawDirection == "L" {
        instruction.direction = Direction::Left;
    } else if rawDirection == "R" {
        instruction.direction = Direction::Right;
    }
    instruction.color = std::stoi(rawHex, 0, 16);
    instruction.debug = (move inputStr);

    return instruction;
}

parseInstructionPart2: (inputStr: std::string) -> DiggerInstruction = {
    instruction: DiggerInstruction = ();
        
    lastSpace := inputStr.find_last_of(' ');
    rawHex := inputStr.substr(lastSpace + 3, inputStr.length() - lastSpace - 4);

    rawNewDistance := rawHex.substr(0, 5);
    rawNewDirection := rawHex[5];

    instruction.distance = std::stoi(rawNewDistance, 0, 16);
    if rawNewDirection == '3' {
        instruction.direction = Direction::Up;
    } else if rawNewDirection == '1' {
        instruction.direction = Direction::Down;
    } else if rawNewDirection == '2' {
        instruction.direction = Direction::Left;
    } else if rawNewDirection == '0' {
        instruction.direction = Direction::Right;
    }
    instruction.debug = (move inputStr);

    return instruction;
}

calculateFloodFillCount: (inout walls: std::vector<DiggerWall>) -> uint64_t = {
    extents := calculateExtents(walls&*);
    totalInside: uint64_t = 0;

    //std::cout << std::endl;
    for std::views::iota(extents.first.y, extents.second.y + 1) do (y) {
        wallHitCount: uint64_t = 0;

        for std::views::iota(extents.first.x, extents.second.x + 1) do (x) {
            currentLocation := Location();
            currentLocation.x = x;
            currentLocation.y = y;

            isInWall := false;
            for walls do (wall) {
                if wall.contains(currentLocation) {
                    if wall.direction == Direction::Up || wall.direction == Direction::Down {
                        if wall.endLocation != currentLocation {
                            wallHitCount += 1;
                        }
                    }
                    isInWall = true;
                }
            }

            if isInWall {
                //std::cout << '#';
                totalInside++; // Walls count as inside
                continue;
            }

            // Only mark as enclosed if we have only hit an odd number of walls
            if wallHitCount % 2 == 1 {
                totalInside++;
                //std::cout << 'X';
            } else {
                //std::cout << '.';
            }
        }
        //std::cout << std::endl;
    }
    //std::cout << std::endl;

    return totalInside;
}

part1: (debugLog: bool) = {
    input: std::ifstream = std::ifstream("inputs/day18.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return;
    }

    inputStr: std::string = ();
    instructions : std::vector<DiggerInstruction> = ();
    while (input.getline(inputStr)) {
        instructions.push_back(parseInstructionPart1(move inputStr));
    }

    currentLocation := Location();
    grid := std::vector<std::vector<i32>>();

    for instructions do (instruction) {
        nextLocation := currentLocation.offset(instruction.distance, instruction.direction);

        if nextLocation.y >= cpp2::unsafe_narrow<i32>(grid.size()) {
            grid.resize(nextLocation.y + 1);

            for std::views::iota(0u, grid.size()) do (rowIndex) {
                grid[rowIndex].resize(grid[0].size(), 0);
            }
        } else if nextLocation.y < 0 {
            gridOffset := std::abs(nextLocation.y);

            for std::views::iota(grid.size(), grid.size() + gridOffset) do (_) {
                grid.insert(grid.begin(), std::vector<i32>());
            }

            for std::views::iota(0u, grid.size()) do (rowIndex) {
                grid[rowIndex].resize(grid.back().size(), 0);
            }

            nextLocation.y += gridOffset;
            currentLocation.y += gridOffset;
        }

        if nextLocation.x >= cpp2::unsafe_narrow<i32>(grid[0].size()) {
            for std::views::iota(0u, grid.size()) do (rowIndex) {
                grid[rowIndex].resize(nextLocation.x + 1, 0);
            }
        } else if nextLocation.x < 0 {
            gridOffset := std::abs(nextLocation.x);
           for std::views::iota(0u, grid.size()) do (rowIndex) {
                for std::views::iota(grid[rowIndex].size(), grid[rowIndex].size() + gridOffset) do (_) {
                    grid[rowIndex].insert(grid[rowIndex].begin(), 0);
                }
            }

            nextLocation.x += gridOffset;
            currentLocation.x += gridOffset;
        }

        if instruction.direction == Direction::Right {
            for std::views::iota(currentLocation.x, nextLocation.x + 1) do (x) {
                grid[currentLocation.y][x] = instruction.color;
            }
        } else if instruction.direction == Direction::Left  {
            for std::views::iota(nextLocation.x, currentLocation.x + 1) do (x) {
                grid[currentLocation.y][x] = instruction.color;
            }
        } else if instruction.direction == Direction::Up {
            for std::views::iota( nextLocation.y, currentLocation.y + 1) do (y) {
                grid[y][currentLocation.x] = instruction.color;
            }
        } else if instruction.direction == Direction::Down {
            for std::views::iota(currentLocation.y, nextLocation.y + 1) do (y) {
                grid[y][currentLocation.x] = instruction.color;
            }
        }

        currentLocation = nextLocation;
        //std::cout << "Instruction: " << instruction.debug << std::endl;
        //grid.print(std::cout);
        //std::cout << std::endl;
    }

    outFileBefore := std::ofstream("out_before.txt");
    outFileAfter := std::ofstream("out_after.txt");


    std::cout << "Before digout:" << std::endl;
    print(grid&*, outFileBefore&*);

    std::cout << "After digout:" << std::endl;

    // Found by hand :D
    start := Location();
    start.x = 248;
    start.y = 16;

    // Debug example
    //start := Location();
    //start.x = 1;
    //start.y = 1;

    grid.digOut(start);
    print(grid&*, outFileAfter&*);

    totalScore := 0;
    for grid do (row) {
        for row do (c) {
            if c != 0 {
                totalScore += 1;
            }
        }
    }

    std::cout << "Part 1: " << totalScore << std::endl;
}

part2: (debugLog: bool) = {
    input: std::ifstream = std::ifstream("inputs/day18_debug1.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return;
    }

    testWall := DiggerWall();
    testWall.startLocation.x = 0;
    testWall.startLocation.y = 0;
    testWall.endLocation.x = 0;
    testWall.endLocation.y = 2;

    testLocation := Location();
    testLocation.x = 0;
    testLocation.y = 1;

    isInWall : = testWall.contains(testLocation);
    isInWall = false;

    inputStr: std::string = ();
    walls: std::vector<DiggerWall> = ();
    startLocation := Location();

    while (input.getline(inputStr)) {
        instruction := parseInstructionPart2(move inputStr);

        endLocation := startLocation.offset(instruction.distance, instruction.direction);

        wall := DiggerWall();

        if instruction.direction == Direction::Up || instruction.direction == Direction::Down {
            if startLocation.y > endLocation.y {
                wall.startLocation = endLocation;
                wall.endLocation = startLocation;
            } else {
                wall.startLocation = startLocation;
                wall.endLocation = endLocation;
            }
        } else {
            if startLocation.x > endLocation.x {
                wall.startLocation = endLocation;
                wall.endLocation = startLocation;
            } else {
                wall.startLocation = startLocation;
                wall.endLocation = endLocation;
            }
        }

        wall.direction = instruction.direction;

        walls.push_back(move wall);
        startLocation = endLocation;
    }

    extents := calculateExtents(walls&*);

    // Move everything positive because I am a mental math baby
    if extents.first.x < 0 {
        for walls do (inout wall) {
            wall.startLocation.x -= extents.first.x;
            wall.endLocation.x -= extents.first.x;
        }
    }
    if extents.first.y < 0 {
        for walls do (inout wall) {
            wall.startLocation.y -= extents.first.y;
            wall.endLocation.y -= extents.first.y;
        }
    }

    insideBitsCount := calculateFloodFillCount(walls&*);

    std::cout << "Part 2: " << insideBitsCount << std::endl;
}

main: () -> int = {
    //part1(true);
    std::cout << std::endl;
    part2(false);

    return 0;
}