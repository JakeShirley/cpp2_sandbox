Direction : @flag_enum<u8> type = {
    None := 0;
    Up;
    Down;
    Left;
    Right;
}

HeatLossCache : @value type = {
    public x: size_t = 0;
    public y: size_t = 0;
    public direction: Direction = Direction::None;
    public spacesInDirection: size_t = 0;
}

StackState : @struct type = {
    public x: size_t;
    public y: size_t;
    public heatLoss: size_t;
    public direction: Direction = Direction::None;
    public spacesInDirection: size_t;
    public path: std::vector<HeatLossCache>;
}

projectCoordinates: (direction: Direction, x: size_t, y: size_t) -> std::tuple<size_t, size_t> = {
    if direction == Direction::Up {
        return std::make_tuple(x, y - 1);
    } else if direction == Direction::Down {
        return std::make_tuple(x, y + 1);
    } else if direction == Direction::Left {
        return std::make_tuple(x - 1, y);
    } else if direction == Direction::Right {
        return std::make_tuple(x + 1, y);
    }
    return std::make_tuple(x, y);
}

printPath: (inout grid: std::vector<std::string>, inout path: std::vector<HeatLossCache>, currentState: std::optional<StackState>) = {
    for std::views::iota(0u, grid.size()) do (lineIndex) {
        for std::views::iota(0u, grid[lineIndex].size()) do (cellIndex) {
            if currentState.has_value() {
                currentStateValue := currentState.value();

                if currentStateValue.x == cellIndex && currentStateValue.y == lineIndex {
                    std::cout << "@";
                    continue;
                }
               
                pathItr := std::find_if(path.begin(), path.end(), :(state) -> bool = {
                    return state.x == cellIndex$ && state.y == lineIndex$;
                });

                if pathItr != path.end() {
                    pathState := pathItr*;
                    if pathState.direction == Direction::Up {
                        std::cout << "^";
                    } else if pathState.direction == Direction::Down {
                        std::cout << "v";
                    } else if pathState.direction == Direction::Left {
                        std::cout << "<";
                    } else if pathState.direction == Direction::Right {
                        std::cout << ">";
                    }
                } else {
                    std::cout << grid[lineIndex][cellIndex];
                }
            } else {
                std::cout << grid[lineIndex][cellIndex];
            }
        }
        std::cout << std::endl;
    }
}

queueTravel: (inout grid: std::vector<std::string>, inout visitQueue: std::priority_queue<StackState, std::vector<StackState>, std::function<bool(StackState, StackState)>>, currentState: StackState, direction: Direction, minDirectionMoves: size_t, maxDirectionMoves: size_t) = {
    nextCoords := projectCoordinates(direction, currentState.x, currentState.y);

    if nextCoords.get<1>() >= grid.size() || nextCoords.get<0>() >= grid[nextCoords.get<1>()].size() {
        return;
    }

    if currentState.direction != direction && currentState.spacesInDirection < minDirectionMoves {
        return;
    }
    if currentState.direction == direction && currentState.spacesInDirection >= maxDirectionMoves {
        return;
    }

    nextState: StackState = (currentState);
    nextState.x = nextCoords.get<0>();
    nextState.y = nextCoords.get<1>();
    nextState.direction = direction;
    nextState.heatLoss += grid[nextState.y][nextState.x] - '0';

    if direction == currentState.direction {
        nextState.spacesInDirection += 1;
    } else {
        nextState.spacesInDirection = 1u;
    }

    // Debug
    pathLocation := HeatLossCache();
    pathLocation.x = currentState.x;
    pathLocation.y = currentState.y;
    pathLocation.direction = direction;
    nextState.path.push_back(move pathLocation);

    visitQueue.push(move nextState);
}

walkPath: (inout grid: std::vector<std::string>, debugLog: bool, startX: size_t, startY: size_t, minDirectionMoves: size_t, maxDirectionMoves: size_t) -> std::vector<StackState> = {
    results: std::vector<StackState> = ();
    comp := :(a, b) -> bool = {
        return a.heatLoss > b.heatLoss;
    };
    visitQueue: std::priority_queue<StackState, std::vector<StackState>, std::function<bool(StackState, StackState)>> = (comp);
    
    heatLossCache: std::map<HeatLossCache, size_t> = ();
    
    goRight: StackState = ();
    goRight.x = startX;
    goRight.y = startY;
    goRight.direction = Direction::Right;
    visitQueue.push(move goRight);

    goDown: StackState = ();
    goDown.x = startX;
    goDown.y = startY;
    goDown.direction = Direction::Down;
    visitQueue.push(move goDown);

    iterationCount := 0;
    while (!visitQueue.empty()) {
        currentState := visitQueue.top();
        visitQueue.pop();

        cacheKey := HeatLossCache();
        cacheKey.x = currentState.x;
        cacheKey.y = currentState.y;
        cacheKey.spacesInDirection = currentState.spacesInDirection;
        cacheKey.direction = currentState.direction;
        heatLossCacheItr := heatLossCache.find(cacheKey);
        if heatLossCacheItr != heatLossCache.end() {
            if currentState.heatLoss < heatLossCacheItr*.second {
                heatLossCache[cacheKey] = currentState.heatLoss;
            } else {
                continue;
            }
        } else {
            heatLossCache[cacheKey] = currentState.heatLoss;
        }
        
        if currentState.y == grid.size() - 1 && currentState.x == grid[0].size() - 1 {
            if currentState.spacesInDirection >= minDirectionMoves {
                results.push_back(move currentState);
            }
            continue;
        }

        iterationCount++;
        if debugLog && iterationCount % 100 == 0{
            std::cout << "Iteration " << iterationCount << ", queue size: " << visitQueue.size() << std::endl;
            printPath(grid, currentState.path, currentState);
            std::cout << std::endl;
        }

        if currentState.direction != Direction::Down {
            queueTravel(grid, visitQueue, currentState, Direction::Up, minDirectionMoves, maxDirectionMoves);
        }
        if currentState.direction != Direction::Right {
            queueTravel(grid, visitQueue, currentState, Direction::Left, minDirectionMoves, maxDirectionMoves);
        }
        if currentState.direction != Direction::Left {
            queueTravel(grid, visitQueue, currentState, Direction::Right, minDirectionMoves, maxDirectionMoves);
        }
        if currentState.direction != Direction::Up {
            queueTravel(grid, visitQueue, currentState, Direction::Down, minDirectionMoves, maxDirectionMoves);
        }
    }

    return results;
}

part1: (debugLog: bool) = {
    input: std::ifstream = std::ifstream("inputs/day17_debug1.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return;
    }

    inputStr: std::string = ();
    lines : std::vector<std::string> = ();
    while (input.getline(inputStr)) {
        lines.push_back(move inputStr);
    }

    result := walkPath(lines&*, debugLog, 0u, 0u, 0u, 3u);

    leastHeatLoss := std::numeric_limits<size_t>::max();
    leastHeatLossState := StackState();
    for result do (resultState) {
        heatLoss := resultState.heatLoss;
        if heatLoss < leastHeatLoss {
            leastHeatLoss = heatLoss;
            leastHeatLossState = resultState;
        }
    }

    printPath(lines&*, leastHeatLossState.path, leastHeatLossState&*);
    std::cout << "Part 1: " << leastHeatLoss << std::endl;
}

part2: (debugLog: bool) = {
     input: std::ifstream = std::ifstream("inputs/day17.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return;
    }

    inputStr: std::string = ();
    lines : std::vector<std::string> = ();
    while (input.getline(inputStr)) {
        lines.push_back(move inputStr);
    }

    result := walkPath(lines&*, debugLog, 0u, 0u, 4u, 10u);

    leastHeatLoss := std::numeric_limits<size_t>::max();
    leastHeatLossState := StackState();
    for result do (resultState) {
        heatLoss := resultState.heatLoss;
        if heatLoss < leastHeatLoss {
            leastHeatLoss = heatLoss;
            leastHeatLossState = resultState;
        }
    }

    printPath(lines&*, leastHeatLossState.path, leastHeatLossState&*);
    std::cout << "Part 2: " << leastHeatLoss << std::endl;
}

main: () -> int = {
    part1(false);
    std::cout << std::endl;
    part2(false);

    return 0;
}