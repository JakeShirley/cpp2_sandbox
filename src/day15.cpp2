
hash: (str: std::string) -> uint64_t = {
    result := 0;
    for str do (c) {
        result += c;
        result *= 17;
        result %= 256;
    }
    return result;
}

print: (boxes: std::array<std::vector<Lens>, 256>) = {
    for std::views::iota(0u, boxes.size()) do (boxId) {
        if boxes[boxId].empty() {
            continue;
        }
        std::cout << "Box " << boxId << ":";
        for boxes[boxId] do (lens) {
            std::cout << " [" << lens.label << " " << lens.focalLength << "]";
        }
        std::cout << std::endl;
    }
}

Lens : @struct type = {
    label: std::string;
    focalLength: uint32_t;
}

part1: () = {
    input: std::ifstream = std::ifstream("inputs/day15.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return;
    }

    inputStr: std::string = ();
    std::getline(input, inputStr);

    inputStringStream := std::istringstream(inputStr);
    inputStringStream.good();
    
    sequenceStr: std::string = ();
    sequences : std::vector<std::string> = ();
    while (std::getline(inputStringStream, sequenceStr, ',')) {
        sequences.push_back(move sequenceStr);
    }

    totalHash : uint64_t = 0;
    for sequences do (sequence) {
        thisHash := sequence.hash();
        totalHash += thisHash;
    }
    
    std::cout << "Part 1: " << totalHash << std::endl;
}

part2: (debugLog: bool) = {
    input: std::ifstream = std::ifstream("inputs/day15_debug.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return;
    }

    inputStr: std::string = ();
    std::getline(input, inputStr);

    inputStringStream := std::istringstream(inputStr);
    inputStringStream.good();
    
    sequenceStr: std::string = ();
    sequences : std::vector<std::string> = ();
    while (std::getline(inputStringStream, sequenceStr, ',')) {
        sequences.push_back(move sequenceStr);
    }

    boxes: std::array<std::vector<Lens>, 256> = ();
    for sequences do (sequence) {
        equalsPos := sequence.find('=');
        dashPos := sequence.find('-');

        if equalsPos != std::string::npos {
            label := sequence.substr(0, equalsPos);
            boxId := label.hash();

            focalStr := sequence.substr(equalsPos + 1);
            focal := std::stoi(focalStr);

            elementItr := std::find_if(boxes[boxId].begin(), boxes[boxId].end(), :(l) -> bool = { return l.label == label$; });

            if elementItr != boxes[boxId].end() {
                elementItr*.focalLength = focal;
            } else {
                newLens : Lens = ();
                newLens.label = label;
                newLens.focalLength = focal;
                boxes[boxId].push_back(move newLens);
            }
        } else if dashPos != std::string::npos {
            label := sequence.substr(0, dashPos);
            boxId := label.hash();

            elementItr := std::find_if(boxes[boxId].begin(), boxes[boxId].end(), :(l) -> bool = { return l.label == label$; });

            if elementItr != boxes[boxId].end() {
                boxes[boxId].erase(elementItr);
            }
        } else {
            std::cout << "Invalid sequence: " << sequence << std::endl;
        }

        if debugLog {
            std::cout << "After \"" << sequence << "\":" << std::endl;
            boxes.print();
            std::cout << std::endl;
        }
    }

    totalFocusPower : uint64_t = 0;
    for std::views::iota(0u, boxes.size()) do (boxId) {
        for std::views::iota(0u, boxes[boxId].size()) do (lensId) {
            totalFocusPower += 
                (boxId + 1) * 
                (lensId + 1) *
                boxes[boxId][lensId].focalLength;
        }
    }

    std::cout << "Part 2: " << totalFocusPower << std::endl;
}

main: () -> int = {
    part1();
    part2(false);

    return 0;
}