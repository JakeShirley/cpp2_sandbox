Direction : @flag_enum<u8> type = {
    None := 0;
    Up;
    Down;
    Left;
    Right;
}

printGrid: (grid: std::vector<std::vector<Direction>>, inout subGrid: std::vector<std::string>, currentLocation: std::optional<std::tuple<size_t, size_t>>) = {
    
    for std::views::iota(0u, grid.size()) do (lineIndex) {
        for std::views::iota(0u, grid[lineIndex].size()) do (cellIndex) {
            if currentLocation.has_value() && currentLocation.value().get<0>() == cellIndex && currentLocation.value().get<1>() == lineIndex {
                std::cout << "@";
                continue;
            } else if subGrid[lineIndex][cellIndex] != '.' {
                std::cout << subGrid[lineIndex][cellIndex];
                continue;
            }
            
            currentValue := grid[lineIndex][cellIndex];
            if currentValue == Direction::Up {
                std::cout << "^";
            } else if currentValue == Direction::Down {
                std::cout << "v";
            } else if currentValue == Direction::Left {
                std::cout << "<";
            } else if currentValue == Direction::Right {
                std::cout << ">";
            } else {
                bitSet: std::bitset<8> = (currentValue.get_raw_value());
                if bitSet.count() == 0 {
                    std::cout << ".";
                } else if bitSet.count() < 10u {
                    std::cout << bitSet.count();
                } else {                 
                    std::cout << "X";
                }
            }
        }
        std::cout << std::endl;
    }
}

projectCoordinates: (direction: Direction, x: size_t, y: size_t) -> std::tuple<size_t, size_t> = {
    if direction == Direction::Up {
        return std::make_tuple(x, y - 1);
    } else if direction == Direction::Down {
        return std::make_tuple(x, y + 1);
    } else if direction == Direction::Left {
        return std::make_tuple(x - 1, y);
    } else if direction == Direction::Right {
        return std::make_tuple(x + 1, y);
    }
    return std::make_tuple(x, y);
}

queueTravel: (inout visitQueue: std::vector<std::tuple<size_t, size_t, Direction>>, direction: Direction, x: size_t, y: size_t) = {
    nextCoords := projectCoordinates(direction, x, y);
    visitQueue.push_back(std::make_tuple(nextCoords.get<0>(), nextCoords.get<1>(), direction));
}

walkPath: (inout grid: std::vector<std::string>, debugLog: bool, startDirection: Direction, startX: size_t, startY: size_t, inout energizedGrid: std::vector<std::vector<Direction>>) = {
    visitQueue: std::vector<std::tuple<size_t, size_t, Direction>> = ();
    
    visitQueue.push_back(std::make_tuple(startX, startY, startDirection));

    iterationCount := 0;
    while (!visitQueue.empty()) {
        x: size_t = visitQueue[0].get<0>();
        y: size_t = visitQueue[0].get<1>();
        direction: Direction = visitQueue[0].get<2>();

        visitQueue.erase(visitQueue.begin());

        if y >= grid.size() || x >= grid[y].size() {
            continue;
        }

        // Already visited this cell twice
        if (energizedGrid[y][x] & direction) != Direction::None {
            energizedGrid[y][x] |= direction;
            continue;
        }
        energizedGrid[y][x] |= direction;

        iterationCount++;
        if debugLog {
            std::cout << "Iteration " << iterationCount << std::endl;
            energizedGrid.printGrid(grid, std::make_tuple(x, y));
            std::cout << std::endl;
        }

        currentChar := grid[y][x];
        isBackSlash := currentChar == '\\'; // cpp2 sucks
        
        if currentChar == '.' {
            queueTravel(visitQueue, direction, x, y);
        } else if currentChar == '|' {
            if direction == Direction::Up || direction == Direction::Down {
                queueTravel(visitQueue, direction, x, y);
            } else {
                queueTravel(visitQueue, Direction::Up, x, y);
                queueTravel(visitQueue, Direction::Down, x, y);
            }
        } else if currentChar == '-' {
            if direction == Direction::Left || direction == Direction::Right {
                queueTravel(visitQueue, direction, x, y);
            } else {
                queueTravel(visitQueue, Direction::Left, x, y);
                queueTravel(visitQueue, Direction::Right, x, y);
            }
        } else if isBackSlash {
            if direction == Direction::Down {
                queueTravel(visitQueue, Direction::Right, x, y);
            } else if direction == Direction::Left {
                queueTravel(visitQueue, Direction::Up, x, y);
            } else if direction == Direction::Right {
                queueTravel(visitQueue, Direction::Down, x, y);
            } else if direction == Direction::Up {
                queueTravel(visitQueue, Direction::Left, x, y);
            }
        } else if currentChar == '/' {
            if direction == Direction::Down {
                queueTravel(visitQueue, Direction::Left, x, y);
            } else if direction == Direction::Left {
                queueTravel(visitQueue, Direction::Down, x, y);
            } else if direction == Direction::Right {
                queueTravel(visitQueue, Direction::Up, x, y);
            } else if direction == Direction::Up {
                queueTravel(visitQueue, Direction::Right, x, y);
            }
        }
    }
}

part1: (debugLog: bool) = {
    input: std::ifstream = std::ifstream("inputs/day16.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return;
    }

    inputStr: std::string = ();
    lines : std::vector<std::string> = ();
    energizedGrid: std::vector<std::vector<Direction>> = ();
    while (input.getline(inputStr)) {
        lines.push_back(move inputStr);

        powerLine: std::vector<Direction> = ();
        powerLine.resize(lines[0].size(), Direction::None);
        energizedGrid.push_back(move powerLine);
    }
    
    if debugLog {
        std::cout << "Before:" << std::endl;
        energizedGrid.printGrid(lines, std::nullopt);
        std::cout << std::endl;
    }

    walkPath(lines&*, debugLog, Direction::Right, 0u, 0u, energizedGrid);

    if debugLog {
        std::cout << "After:" << std::endl;
        energizedGrid.printGrid(lines&*, std::nullopt);
        std::cout << std::endl;
    }

    totalEnergizedPlots := 0u;
    for energizedGrid do (line) {
        for line do (cell) {
            if cell != Direction::None {
                totalEnergizedPlots++;
            }
        }
    }

    std::cout << "Part 1: " << totalEnergizedPlots << std::endl;
}

getTotalEnegery: (inout grid: std::vector<std::string>, debugLog: bool, startDirection: Direction, startX: size_t, startY: size_t, inout energizedGridTemplate: std::vector<std::vector<Direction>>) -> uint64_t = {
    energizedGrid := energizedGridTemplate;
    walkPath(grid, debugLog, startDirection, startX, startY, energizedGrid);

    totalEnergizedPlots := 0u;
    for energizedGrid do (line) {
        for line do (cell) {
            if cell != Direction::None {
                totalEnergizedPlots++;
            }
        }
    }

    return totalEnergizedPlots;
}

part2: (debugLog: bool) = {
    input: std::ifstream = std::ifstream("inputs/day16.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return;
    }

    inputStr: std::string = ();
    lines : std::vector<std::string> = ();
    energizedGridTemplate: std::vector<std::vector<Direction>> = ();
    while (input.getline(inputStr)) {
        lines.push_back(move inputStr);

        powerLine: std::vector<Direction> = ();
        powerLine.resize(lines[0].size(), Direction::None);
        energizedGridTemplate.push_back(move powerLine);
    }

    maxEnergizedPlots : uint64_t = 0u;

    // Top and bottom
    for std::views::iota(0u, lines[0].size()) do (cellIndex) {
        topEnergy := getTotalEnegery(lines&*, debugLog, Direction::Down, cellIndex, 0, energizedGridTemplate);
        bottomEnergy := getTotalEnegery(lines&*, debugLog, Direction::Up, cellIndex, lines.size() - 1, energizedGridTemplate);
    
        maxEnergizedPlots = std::max(maxEnergizedPlots, topEnergy);
        maxEnergizedPlots = std::max(maxEnergizedPlots, bottomEnergy);
    }

    // Left and right
    for std::views::iota(0u, lines.size()) do (lineIndex) {
        rightEnergy := getTotalEnegery(lines&*, debugLog, Direction::Right, 0, lineIndex, energizedGridTemplate);
        leftEnergy := getTotalEnegery(lines&*, debugLog, Direction::Left, lines[lineIndex].size() - 1, lineIndex, energizedGridTemplate);
    
        maxEnergizedPlots = std::max(maxEnergizedPlots, rightEnergy);
        maxEnergizedPlots = std::max(maxEnergizedPlots, leftEnergy);
    }
    

    std::cout << "Part 2: " << maxEnergizedPlots << std::endl;
}

main: () -> int = {
    part1(false);
    part2(false);

    return 0;
}