
MapNode : @struct type = {
    key: std::string = ();
    left: std::string = ();
    right: std::string = ();
}

part1: () -> int = {
    input: std::ifstream = std::ifstream("inputs/day8.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return -1;
    }

    instructions: std::string = ();
    std::getline(input, instructions);

    nodes: std::unordered_map<std::string, MapNode> = ();
    inputStr: std::string = ();
    while (std::getline(input, inputStr)) {
        if inputStr.empty() {
            continue;
        }

        mapNode := MapNode();

        mapNode.key = inputStr.substr(0, inputStr.find_first_of(' '));

        valueStart := inputStr.find_first_of('(');
        valueEnd := inputStr.find_last_of(')');

        rightStart := inputStr.find_last_of(' ') + 1;
        comma := inputStr.find(',');

        mapNode.left = inputStr.substr(valueStart + 1, comma - valueStart - 1);
        mapNode.right = inputStr.substr(rightStart, valueEnd - rightStart);

        nodes[mapNode.key] = mapNode;
    }

    traversalCount : uint64_t = 0;
    instructionIndex: size_t = 0;
    currentNode := nodes["AAA"];
    while true {
        traversalCount++;
        currentInstruction := instructions[instructionIndex];

        if currentInstruction == 'L' {
            currentNode = nodes.at(currentNode.left);
        } else if currentInstruction == 'R' {
            currentNode = nodes.at(currentNode.right);
        }

        if currentNode.key == "ZZZ" {
            break;
        }

        instructionIndex = (instructionIndex + 1) % instructions.size();
    }

    std::cout << "Total hops: " << traversalCount << std::endl;

    return 0;
}

isStartingNode: (node: MapNode) -> bool = {
    return node.key.find("A") != std::string::npos;
}

isEndingNode: (node: MapNode) -> bool = {
    return node.key.find("Z") != std::string::npos;
}

getStepsToEndNode: (instructions: std::string, nodes: std::unordered_map<std::string, MapNode>, startingNode: MapNode) -> uint64_t = {
    traversalCount : uint64_t = 0;
    instructionIndex: size_t = 0;
    currentNode := startingNode;
    while true {
        traversalCount++;
        currentInstruction := instructions[instructionIndex];

        if currentInstruction == 'L' {
            currentNode = nodes.at(currentNode.left);
        } else if currentInstruction == 'R' {
            currentNode = nodes.at(currentNode.right);
        }

        if isEndingNode(currentNode) {
            break;
        }

        instructionIndex = (instructionIndex + 1) % instructions.size();
    }

    return traversalCount;
}

part2: () -> int = {
    input := std::ifstream("inputs/day8.txt");
    if (!input.is_open()) {
        std::cout << "Failed to open file" << std::endl;
        return -1;
    }

    instructions: std::string = ();
    input.getline(instructions&*);

    nodes: std::unordered_map<std::string, MapNode> = ();
    inputStr: std::string = ();
    while (std::getline(input, inputStr)) {
        if inputStr.empty() {
            continue;
        }

        mapNode := MapNode();

        mapNode.key = inputStr.substr(0, inputStr.find_first_of(' '));

        valueStart := inputStr.find_first_of('(');
        valueEnd := inputStr.find_last_of(')');

        rightStart := inputStr.find_last_of(' ') + 1;
        comma := inputStr.find(',');

        mapNode.left = inputStr.substr(valueStart + 1, comma - valueStart - 1);
        mapNode.right = inputStr.substr(rightStart, valueEnd - rightStart);

        nodes[mapNode.key] = mapNode;
    }

    pathLengths := std::vector<uint64_t>();
    for nodes do (startingNode) {
        if isStartingNode(startingNode.second) {
            pathLengths.push_back(getStepsToEndNode(instructions, nodes, startingNode.second));
        }
    }

    lcm: uint64_t = 1;
    for pathLengths do (pathLength) {
        lcm = std::lcm(lcm, pathLength);
    }

    std::cout << "LCM: " << lcm << std::endl;

    return 0;
}

main: () -> int = {
    //return part1();
    return part2();
}